<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Notes on developer velocity</title>
    <link type="application/atom+xml" rel="alternate" href="https://www.hamishpierpont.com/feed.xml" title="Hamish Pierpont&apos;s blog" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Notes on developer velocity | Hamish Pierpont’s blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Notes on developer velocity" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I am a software engineer, just shy of two years into my career. My team and I have spent the last few months closing out a major effort, with lots of pressure Inspired by similar posts by Dan Luu and Jamie Brandon, I addressed this challenge by putting lots of effort into improving my throughput. I’m happy with this result: using the highly flawed metric of “story points completed per sprint,” my output tracks 50 to 100% higher than it used to, with no discernible change in the way we estimate task complexity. More tangibly, I added a big nasty feature to our product, which is one of the top priorities for my organization. Here are a few notes about what worked. Note that this post is about getting a lot done. It’s not a justification for overwork, or an endorsement of working outside business hours - it’s just one person’s thoughts about how to get a lot done when the time calls for it. I don’t have kids, I live a short walk to my place of work, and my level of expertise relative to that of my peers is low, even though that gap is closing. I’m also in the uncommon - but not unique - situation of working in an office with none of my close coworkers working from that same office, so I have unusually high autonomy in how I spend my time. The opportunity cost of not getting lunch with your manager is not a concern when your manager is three states away. Keep feedback loops as short as possible When under constant pressure to close tickets and put out fires, developers rarely get to step back and examine their processes. This often leads to inefficient team processes that: Could be optimized with a few days of developer attention or less Routinely waste hours of developer time Do not directly relate to adding features, and therefore often go overlooked for days or months. Individual level: testing practices My IDE reports problems with my code with a latency of a few seconds. The Maven tasks for our repository take anywhere from a few seconds to a minutes. A full local build running checkstyle, unit tests, and coverage analysis takes five or six minutes. Running integration tests locally might take ten minutes. Running our full dev pipeline on Jenkins takes at least an hour if there are no builds in the queue. My golden rule is to never let a problem that could be caught in a shorter feedback loop go undetected until a longer one is run. This saves time in two ways: by not wasting forty-five minutes of pipeline build time on a code style issue that could have been caught with a fifteen-second run of mvn:checkstyle check, and by shortening feedback loops to the point where I don’t feel tempted to switch tasks. Returning to my original productivity level after a context switch takes a few minutes at least, and I think that every context switch through the day accumulates slime on the surface of my brain that makes it harder to focus. This suggests running all the various checks on your work in ascending order of their time length - e.g. run the linter first. When I didn’t feel the need to squeeze the most out of every minute and hour, I wasn’t as strict with this rule and wasted lots of time as a result. This also suggests adding everything into your IDE that you can. My team uses SonarQube to enforce code quality in our pipeline, but never set up SonarQube integration in our IDEs. We’ve had several pipeline builds fail due to SonarQube code smells. Every time this happens we need to hunt down the exact issue in the SonarQube dashboard (the link to SonarQube in our pipeline logs has been broken for months so it’s not as simple as clicking the last line in the logs), resolve the issue, re-run our unit tests and checkstyle locally to make sure nothing changed, then push the changes and wait for the pipeline to build again. This is a mind-boggling waste of time when SonarQube integration in IntelliJ can highlight these problems immediately. Team level: end to end testing My team went several months without a way to test our frontend against our backend on our local machines. The config for the frontend pointed to the QA backend endpoint, even when the frontend was running locally. The fix wasn’t obvious because we don’t own the frontend or backend, and our compressed schedule meant we didn’t feel comfortable spending time on anything other than grinding through tickets. However, since we often had five different people working on features in the backend repository and all of their pull requests overwrote the QA backend service with each PR build, we were constantly stepping on each other’s toes; five minutes after my PR build deployed to QA and I could start testing my frontend and backend changes against each other, my teammate’s PR build would deploy to QA and overwrite my changes. This constant resource contention just to test frontend and backend changes together wasted days of developer time. One evening, I finally dug through the frontend code and found where the logic to send requests to our backend lived. I spent two hours tinkering with it and made some progress, but got confused by an issue with HTTPS and certificates. (Remember, I’m still pretty green). The next morning I handed my work to my senior developer during standup, and in a few hours he had figured out the cert issue. By the end of that day we all knew how to test our frontend changes against our backend changes locally. The feedback loop for testing frontend and backend changes against each other was immediately reduced from hours/days to one or two minutes. Ever since this change we’ve gone from barely fitting our tickets into the sprint or underdelivering on them to pulling fresh tickets from the backlog halfway through each sprint. Org level: pull request norms My team is currently on loan to help another project get across the finish line, so we don’t own any of the codebases or pipelines to which we contribute. We need approvals from the team that owns the project to merge pull requests. A common issue we run into is creating a big pull request, sending it off for review from that team, and then having to remind them aggressively to review our PRs, often not seeing reviews for several days. That team has to deal with lots of production incidents, owns multiple critical services, and has their own raft of PRs to review, so it’s not surprising that they aren’t always quick to review our PRs. They also do not trust our developers as much to write good code, since we have only worked with them for a few months and we spent much of that time learning the ropes. However, they do trust our manager, who they see frequently in cross-team meetings and outranks everyone on my team by one to three levels. When we instituted a team norm of getting PR approvals from at least one developer from our team and our manager before sending to our sister team for review, we saw a significant decrease in wait times for PR reviews. Another pernicious time-waster is undergoing multiple rounds of PR feedback, especially given the long lead time on PR reviews in my organization. Every round of requested changes requires another cycle of testing and PR builds that will take a few hours at minimum, possibly extending to a day or more if the pipeline is unstable or the clusters are being rehydrated. Some of this is irreducible complexity in the tasks, but after my first few PRs I noticed some common patterns of feedback. I started keeping track of this in my note-taking app, which eventually grew into a PR checklist. By reviewing my changes against the checklist every time I have something to contribute, I make sure that I won’t burn one or two PR review cycles on obvious things that my sister team will dislike; keeping this information in a note outside my head ensures I don’t forget anything. Become extremely comfortable with asking for help and asking questions I basically never needed to ask for help in grade school, and got through most of college without needing it either, so I came into my full-time engineering career uncomfortable with asking lots of questions because I didn’t want to look stupid. This seems to be a common failure mode for newer engineers. It is also one of the most damaging, because being a software developer is nothing like being a student. Since your team needs to get work done, in effect everything is a group project, and you need to pull your weight. But since you don’t know anything, and a lot of the requisite knowledge lives only in the heads of your fellow engineers, you will not be able to pull your weight until substantial amounts of senior engineer time has been spent teaching you. This is not a new revelation from the last few months, but its truth was borne out by the last few months. I had to implement a new frontend component in Angular. I have never written any real frontend code in my life. I could have grokked the basics from watching any Angular tutorial, but the specific knowledge of the codebase required to complete the work had to be transmitted into me directly from the brains of my fellow engineers. I spent tremendous amounts of time programming with my teammates during this effort. I would not have finished without them - just as an example, it took me and my senior engineer three days to get the frontend tests working for my changes, partially because we discovered bugs in the testing suite we inherited. If I had wasted too much time trying to understand it myself, I would have still needed to take several days of my senior engineer’s time, but I would have endangered our team’s timeline while doing it. A critical skill is to learn exactly when you should stop trying to figure something out and call for help. For me, since some of that psychological discomfort with asking for help remains, I often time-box how long I will allow myself to spin my wheels. This is often down to the five- or ten-minute mark: “if I can’t figure out the next step on this work by ten minutes from now, I’m asking for help.” Note that this is strictly inferior to asking right when you realize you’re stuck - this technique just guards against wasting an hour or more. In the same vein, I often find myself so confused that it’s hard to intelligently articulate my questions. When that happens, it’s a sign that other engineers need to be pulled in so I can talk it out with them. This is uncomfortable - stuttering through an explanation of what’s happening and grasping at the specific point of confusion is uncomfortable - but the options are to wrangle it by yourself and possibly burn an entire day trying to figure it out, or spend five to ten minutes vomiting words at your coworkers until all of a sudden the problem becomes clear. Your coworkers will be happy to spend this ten minutes if it means you actually accomplish your work and they don’t need to pick up the slack later. Be particular in refinement My team has landed on an objective standard for ticket refinement: every ticket should have enough information that any developer on the team could pick it up and know where to start, even if that doesn’t happen until several weeks from now. Since I am the newest on the team by a wide margin - and since one of my strengths is attention to detail - I often am the one asking for multiple rounds of clarifications to be made until the ticket reaches this standard. Consequently, I no longer get tickets that I find confusing - I can almost always get started on them the day I pick them up without needing to hunt people down for clarification. If this saves a few hours per sprint, which I think it does, then that’s pretty huge. This is another win with team-level benefits. I was in sprint retro earlier, and one of my team members called out how much easier it was to finish tickets on time without having to figure out what the ticket meant, often going back and forth with the ticket author to figure it out. This validates that other developers had the same issue and also wasted several hours each sprint. Dump and serialize mental state I take lots of notes at work, mostly using a journal format with one markdown file per day. At the end of the workday, I create the note for the next day and add a to-do list ordered with the most pressing or time-sensitive task at the top. I’ll also write out bullet points for standup outlining what I accomplished the day before, what I’ll aim to accomplish that day, any blockers, and any topics to discuss during our parking lot. By dumping my current mental state at the end of the workday into this note and structuring it in this manner, I find it a lot easier to relax after work knowing that the pertinent info I’ll need for the next day is written down. I also give much more thoughtful and detailed standup updates, surfacing any issues that require team help and proving to my coworkers (including my manager and PM) that I am actually getting a lot done. Having this clear log of what’s getting done also helps a lot during performance management, as I can refer to examples of good work down to the day it was completed. Finally, arriving at work knowing exactly what to do first lets me capitalize on my most productive hours in the morning. Sometimes this means staying an extra fifteen minutes to collate the information, but I think it’s worth it. Always capitalize on your most productive hours Some people are morning people and some people are night people. I, myself, am an “everytime but mid-afternoon” person - I can be laser-focused in the morning until my first meeting and pretty good until I break for lunch, which takes a while to come back from. Getting anything done from 2:30 to 4:30 requires an elaborate array of ruses and tricks. Knowing this, I try to get in before the morning rush so I can get to work before the office fills with people - normally around 8:45 AM. I’ll also delay lunch to 12:30 or later and keep it short by bringing lunch from home. Elongating my morning from three hours to four-ish is an incredible boon to my productivity, especially the time I gain before my 10am standup. I do still socialize at lunch, but maybe a bit less than normal. For the rest of the working day, I’ll do my best to focus. Sometimes I do so quite successfully! Sometimes I’m booked solid with meetings, or just have a hard time focusing, but this matters less when I spend the first four hours of the day in productive bliss. I try not to work much past 5pm, but sometimes it can’t be avoided. When I do, I find that I can actually do quite a bit once the office thins out around 5pm and the distractions go away. I’ll work until 7pm at the latest, normally getting quite a bit done. Then I’ll put the computer down, walk home, eat, and get on with my evening. If the mood strikes me, I’ll re-open my computer briefly sometime between 10:30 and 11. My brain is now well-rested and can fit in a small, discrete task before I got to bed at midnight - like drafting a pull request description, writing my to-do list, or outlining what I’ll say in standup so I don’t have to use productive morning time for it. This time helps me align my priorities for the next day to ensure I tackle the most important thing right when I get started. Work where you are most productive I struggle mightily with working from home, and have for as long as I can remember. In high school I could knock out math homework in a thirty-minute lunch, while eating, that might have taken me more than an hour at home. In college my grades correlated highly with how much time I spent in the library and in cafes - I’d work from my apartment only if I was in real trouble. (When COVID made all learning remote, you can imagine how fucked I was). I spent the first six months of my full-time job working from my parents’ house in Florida, and I only got decent results by working brutal hours and having a lot of prior experience - my median per-hour productivity sucked. For this reason I go to the office all five days a week, despite my company only mandating 2.5 days a week. It’s just much easier for me to get work done, especially on Mondays and Fridays when the office is dead. If I felt that I was much more productive working from home, I would be scheming every way possible to maximize my time spent working from home, including applying for a remote exception at my job. This idea goes hand in glove with working during hours of peak productivity. Working in my best environment, when I feel sharpest, is a game changer. Always have work in the queue Despite all the efforts to reduce our time spent waiting, tasks inevitably get blocked and context switching becomes necessary. I make sure to always have other work queued up and ready to go. When I write down my to-do list at the end of every day, even if I expect to spend the entire next day on a certain effort, I make sure I have the next step for another effort added to the end of my to-do list so I can go straight into it once I’m blocked. If I don’t know what this next task is, I know I need to bring it up in standup the next day to get help understanding the context of the ticket - but then again, since I’m persistent in refinement, I normally know the next step for each task. Do all the “life” stuff you already know you should be doing When my nightly sleep drops below seven hours per night, I start having terrible days at work where I get nothing done and lose track of work discussions. If I’m not eating well, it exacerbates the negative performance effects of working in the afternoon and affects my sleep. If I’m not exercising (which for me is lifting weights, running, and walking everywhere), I can’t sit still at work long enough to focus. Everyone already knows that they should be sleeping to the point of maximal focus, doing regular exercise, and eating a balanced diet. If you feel you struggle with any of these, it’s worth the time and effort to figure out why. I wasted five years of my life sleeping terribly because I drank black coffee and diet soda like it was water, so I never felt the full effects of sleepiness and never made the effort to sleep better. Nowadays I’m much more cautious about my caffeine intake and my sleep is much better. There was a point in my life where I neither ate well nor exercised. It took a lot of careful self-observation and journaling to convince myself of their benefits, but now it’s obvious to me when I’m not doing them because I feel absolutely terrible. If any of these start slipping, it shows up in my work performance and I know I need to course-correct. General thoughts on process and takeaways In the last few months I suddenly had to care about being more productive, and then I got more productive. This echoes Jamie Brandon’s thoughts on moving faster: the most powerful precursor to moving faster is caring about moving faster. A lot of the most powerful things on this list come not from reading books or blog posts on productivity, but instead from observing and taking notes and then trying to deal with my individual problems and bottlenecks. I think this is underrated across most domains. The biggest wins on this list are team-centric: instituting team norms around pull requests and refinement, getting the entire team a working local setup, reducing our team’s dependence on a flaky and competitive QA environment, getting help from teammates and using these meetings to spread context throughout the team, ensuring I come to standup with extremely detailed updates to keep the team informed, etc. I think it goes without saying that overall team productivity matters more than individual productivity, and that communication is a big source of latency and therefore an obvious place to optimize (alternatively, that team-wide improvements yield far more). However, I find that the faster I can deal with my own tasks, the more breathing room I have to consider how the team could be working more smoothly. Things I have not tried but think might work Recording myself programming and reviewing the tapes I don’t do enough programming outside work hours to justify this, and I’d feel weird setting up screen-recording on a work laptop. This would help answer a lot of questions I have: How does listening to music affect my productivity? What do I do differently on productive afternoons when compared to my less productive afternoons? I have theories on the above, but actually watching it happening would be better. Further reading Dan Luu’s “Some reasons to work on productivity and velocity” I mostly agree with his takeaways here, which is why I didn’t spend much time trying to justify why working on velocity is worth it Jamie Brandon’s “Speed Matters” and “Moving Faster” The specific speedup figures - e.g. “if you improve your velocity 10x you can do 5x every morning and go home after lunch” - reflect his never working on teams in a professional software engineering environment Cal Newport’s Deep Work The most relevant part here is about context switching and attention residue" />
<meta property="og:description" content="I am a software engineer, just shy of two years into my career. My team and I have spent the last few months closing out a major effort, with lots of pressure Inspired by similar posts by Dan Luu and Jamie Brandon, I addressed this challenge by putting lots of effort into improving my throughput. I’m happy with this result: using the highly flawed metric of “story points completed per sprint,” my output tracks 50 to 100% higher than it used to, with no discernible change in the way we estimate task complexity. More tangibly, I added a big nasty feature to our product, which is one of the top priorities for my organization. Here are a few notes about what worked. Note that this post is about getting a lot done. It’s not a justification for overwork, or an endorsement of working outside business hours - it’s just one person’s thoughts about how to get a lot done when the time calls for it. I don’t have kids, I live a short walk to my place of work, and my level of expertise relative to that of my peers is low, even though that gap is closing. I’m also in the uncommon - but not unique - situation of working in an office with none of my close coworkers working from that same office, so I have unusually high autonomy in how I spend my time. The opportunity cost of not getting lunch with your manager is not a concern when your manager is three states away. Keep feedback loops as short as possible When under constant pressure to close tickets and put out fires, developers rarely get to step back and examine their processes. This often leads to inefficient team processes that: Could be optimized with a few days of developer attention or less Routinely waste hours of developer time Do not directly relate to adding features, and therefore often go overlooked for days or months. Individual level: testing practices My IDE reports problems with my code with a latency of a few seconds. The Maven tasks for our repository take anywhere from a few seconds to a minutes. A full local build running checkstyle, unit tests, and coverage analysis takes five or six minutes. Running integration tests locally might take ten minutes. Running our full dev pipeline on Jenkins takes at least an hour if there are no builds in the queue. My golden rule is to never let a problem that could be caught in a shorter feedback loop go undetected until a longer one is run. This saves time in two ways: by not wasting forty-five minutes of pipeline build time on a code style issue that could have been caught with a fifteen-second run of mvn:checkstyle check, and by shortening feedback loops to the point where I don’t feel tempted to switch tasks. Returning to my original productivity level after a context switch takes a few minutes at least, and I think that every context switch through the day accumulates slime on the surface of my brain that makes it harder to focus. This suggests running all the various checks on your work in ascending order of their time length - e.g. run the linter first. When I didn’t feel the need to squeeze the most out of every minute and hour, I wasn’t as strict with this rule and wasted lots of time as a result. This also suggests adding everything into your IDE that you can. My team uses SonarQube to enforce code quality in our pipeline, but never set up SonarQube integration in our IDEs. We’ve had several pipeline builds fail due to SonarQube code smells. Every time this happens we need to hunt down the exact issue in the SonarQube dashboard (the link to SonarQube in our pipeline logs has been broken for months so it’s not as simple as clicking the last line in the logs), resolve the issue, re-run our unit tests and checkstyle locally to make sure nothing changed, then push the changes and wait for the pipeline to build again. This is a mind-boggling waste of time when SonarQube integration in IntelliJ can highlight these problems immediately. Team level: end to end testing My team went several months without a way to test our frontend against our backend on our local machines. The config for the frontend pointed to the QA backend endpoint, even when the frontend was running locally. The fix wasn’t obvious because we don’t own the frontend or backend, and our compressed schedule meant we didn’t feel comfortable spending time on anything other than grinding through tickets. However, since we often had five different people working on features in the backend repository and all of their pull requests overwrote the QA backend service with each PR build, we were constantly stepping on each other’s toes; five minutes after my PR build deployed to QA and I could start testing my frontend and backend changes against each other, my teammate’s PR build would deploy to QA and overwrite my changes. This constant resource contention just to test frontend and backend changes together wasted days of developer time. One evening, I finally dug through the frontend code and found where the logic to send requests to our backend lived. I spent two hours tinkering with it and made some progress, but got confused by an issue with HTTPS and certificates. (Remember, I’m still pretty green). The next morning I handed my work to my senior developer during standup, and in a few hours he had figured out the cert issue. By the end of that day we all knew how to test our frontend changes against our backend changes locally. The feedback loop for testing frontend and backend changes against each other was immediately reduced from hours/days to one or two minutes. Ever since this change we’ve gone from barely fitting our tickets into the sprint or underdelivering on them to pulling fresh tickets from the backlog halfway through each sprint. Org level: pull request norms My team is currently on loan to help another project get across the finish line, so we don’t own any of the codebases or pipelines to which we contribute. We need approvals from the team that owns the project to merge pull requests. A common issue we run into is creating a big pull request, sending it off for review from that team, and then having to remind them aggressively to review our PRs, often not seeing reviews for several days. That team has to deal with lots of production incidents, owns multiple critical services, and has their own raft of PRs to review, so it’s not surprising that they aren’t always quick to review our PRs. They also do not trust our developers as much to write good code, since we have only worked with them for a few months and we spent much of that time learning the ropes. However, they do trust our manager, who they see frequently in cross-team meetings and outranks everyone on my team by one to three levels. When we instituted a team norm of getting PR approvals from at least one developer from our team and our manager before sending to our sister team for review, we saw a significant decrease in wait times for PR reviews. Another pernicious time-waster is undergoing multiple rounds of PR feedback, especially given the long lead time on PR reviews in my organization. Every round of requested changes requires another cycle of testing and PR builds that will take a few hours at minimum, possibly extending to a day or more if the pipeline is unstable or the clusters are being rehydrated. Some of this is irreducible complexity in the tasks, but after my first few PRs I noticed some common patterns of feedback. I started keeping track of this in my note-taking app, which eventually grew into a PR checklist. By reviewing my changes against the checklist every time I have something to contribute, I make sure that I won’t burn one or two PR review cycles on obvious things that my sister team will dislike; keeping this information in a note outside my head ensures I don’t forget anything. Become extremely comfortable with asking for help and asking questions I basically never needed to ask for help in grade school, and got through most of college without needing it either, so I came into my full-time engineering career uncomfortable with asking lots of questions because I didn’t want to look stupid. This seems to be a common failure mode for newer engineers. It is also one of the most damaging, because being a software developer is nothing like being a student. Since your team needs to get work done, in effect everything is a group project, and you need to pull your weight. But since you don’t know anything, and a lot of the requisite knowledge lives only in the heads of your fellow engineers, you will not be able to pull your weight until substantial amounts of senior engineer time has been spent teaching you. This is not a new revelation from the last few months, but its truth was borne out by the last few months. I had to implement a new frontend component in Angular. I have never written any real frontend code in my life. I could have grokked the basics from watching any Angular tutorial, but the specific knowledge of the codebase required to complete the work had to be transmitted into me directly from the brains of my fellow engineers. I spent tremendous amounts of time programming with my teammates during this effort. I would not have finished without them - just as an example, it took me and my senior engineer three days to get the frontend tests working for my changes, partially because we discovered bugs in the testing suite we inherited. If I had wasted too much time trying to understand it myself, I would have still needed to take several days of my senior engineer’s time, but I would have endangered our team’s timeline while doing it. A critical skill is to learn exactly when you should stop trying to figure something out and call for help. For me, since some of that psychological discomfort with asking for help remains, I often time-box how long I will allow myself to spin my wheels. This is often down to the five- or ten-minute mark: “if I can’t figure out the next step on this work by ten minutes from now, I’m asking for help.” Note that this is strictly inferior to asking right when you realize you’re stuck - this technique just guards against wasting an hour or more. In the same vein, I often find myself so confused that it’s hard to intelligently articulate my questions. When that happens, it’s a sign that other engineers need to be pulled in so I can talk it out with them. This is uncomfortable - stuttering through an explanation of what’s happening and grasping at the specific point of confusion is uncomfortable - but the options are to wrangle it by yourself and possibly burn an entire day trying to figure it out, or spend five to ten minutes vomiting words at your coworkers until all of a sudden the problem becomes clear. Your coworkers will be happy to spend this ten minutes if it means you actually accomplish your work and they don’t need to pick up the slack later. Be particular in refinement My team has landed on an objective standard for ticket refinement: every ticket should have enough information that any developer on the team could pick it up and know where to start, even if that doesn’t happen until several weeks from now. Since I am the newest on the team by a wide margin - and since one of my strengths is attention to detail - I often am the one asking for multiple rounds of clarifications to be made until the ticket reaches this standard. Consequently, I no longer get tickets that I find confusing - I can almost always get started on them the day I pick them up without needing to hunt people down for clarification. If this saves a few hours per sprint, which I think it does, then that’s pretty huge. This is another win with team-level benefits. I was in sprint retro earlier, and one of my team members called out how much easier it was to finish tickets on time without having to figure out what the ticket meant, often going back and forth with the ticket author to figure it out. This validates that other developers had the same issue and also wasted several hours each sprint. Dump and serialize mental state I take lots of notes at work, mostly using a journal format with one markdown file per day. At the end of the workday, I create the note for the next day and add a to-do list ordered with the most pressing or time-sensitive task at the top. I’ll also write out bullet points for standup outlining what I accomplished the day before, what I’ll aim to accomplish that day, any blockers, and any topics to discuss during our parking lot. By dumping my current mental state at the end of the workday into this note and structuring it in this manner, I find it a lot easier to relax after work knowing that the pertinent info I’ll need for the next day is written down. I also give much more thoughtful and detailed standup updates, surfacing any issues that require team help and proving to my coworkers (including my manager and PM) that I am actually getting a lot done. Having this clear log of what’s getting done also helps a lot during performance management, as I can refer to examples of good work down to the day it was completed. Finally, arriving at work knowing exactly what to do first lets me capitalize on my most productive hours in the morning. Sometimes this means staying an extra fifteen minutes to collate the information, but I think it’s worth it. Always capitalize on your most productive hours Some people are morning people and some people are night people. I, myself, am an “everytime but mid-afternoon” person - I can be laser-focused in the morning until my first meeting and pretty good until I break for lunch, which takes a while to come back from. Getting anything done from 2:30 to 4:30 requires an elaborate array of ruses and tricks. Knowing this, I try to get in before the morning rush so I can get to work before the office fills with people - normally around 8:45 AM. I’ll also delay lunch to 12:30 or later and keep it short by bringing lunch from home. Elongating my morning from three hours to four-ish is an incredible boon to my productivity, especially the time I gain before my 10am standup. I do still socialize at lunch, but maybe a bit less than normal. For the rest of the working day, I’ll do my best to focus. Sometimes I do so quite successfully! Sometimes I’m booked solid with meetings, or just have a hard time focusing, but this matters less when I spend the first four hours of the day in productive bliss. I try not to work much past 5pm, but sometimes it can’t be avoided. When I do, I find that I can actually do quite a bit once the office thins out around 5pm and the distractions go away. I’ll work until 7pm at the latest, normally getting quite a bit done. Then I’ll put the computer down, walk home, eat, and get on with my evening. If the mood strikes me, I’ll re-open my computer briefly sometime between 10:30 and 11. My brain is now well-rested and can fit in a small, discrete task before I got to bed at midnight - like drafting a pull request description, writing my to-do list, or outlining what I’ll say in standup so I don’t have to use productive morning time for it. This time helps me align my priorities for the next day to ensure I tackle the most important thing right when I get started. Work where you are most productive I struggle mightily with working from home, and have for as long as I can remember. In high school I could knock out math homework in a thirty-minute lunch, while eating, that might have taken me more than an hour at home. In college my grades correlated highly with how much time I spent in the library and in cafes - I’d work from my apartment only if I was in real trouble. (When COVID made all learning remote, you can imagine how fucked I was). I spent the first six months of my full-time job working from my parents’ house in Florida, and I only got decent results by working brutal hours and having a lot of prior experience - my median per-hour productivity sucked. For this reason I go to the office all five days a week, despite my company only mandating 2.5 days a week. It’s just much easier for me to get work done, especially on Mondays and Fridays when the office is dead. If I felt that I was much more productive working from home, I would be scheming every way possible to maximize my time spent working from home, including applying for a remote exception at my job. This idea goes hand in glove with working during hours of peak productivity. Working in my best environment, when I feel sharpest, is a game changer. Always have work in the queue Despite all the efforts to reduce our time spent waiting, tasks inevitably get blocked and context switching becomes necessary. I make sure to always have other work queued up and ready to go. When I write down my to-do list at the end of every day, even if I expect to spend the entire next day on a certain effort, I make sure I have the next step for another effort added to the end of my to-do list so I can go straight into it once I’m blocked. If I don’t know what this next task is, I know I need to bring it up in standup the next day to get help understanding the context of the ticket - but then again, since I’m persistent in refinement, I normally know the next step for each task. Do all the “life” stuff you already know you should be doing When my nightly sleep drops below seven hours per night, I start having terrible days at work where I get nothing done and lose track of work discussions. If I’m not eating well, it exacerbates the negative performance effects of working in the afternoon and affects my sleep. If I’m not exercising (which for me is lifting weights, running, and walking everywhere), I can’t sit still at work long enough to focus. Everyone already knows that they should be sleeping to the point of maximal focus, doing regular exercise, and eating a balanced diet. If you feel you struggle with any of these, it’s worth the time and effort to figure out why. I wasted five years of my life sleeping terribly because I drank black coffee and diet soda like it was water, so I never felt the full effects of sleepiness and never made the effort to sleep better. Nowadays I’m much more cautious about my caffeine intake and my sleep is much better. There was a point in my life where I neither ate well nor exercised. It took a lot of careful self-observation and journaling to convince myself of their benefits, but now it’s obvious to me when I’m not doing them because I feel absolutely terrible. If any of these start slipping, it shows up in my work performance and I know I need to course-correct. General thoughts on process and takeaways In the last few months I suddenly had to care about being more productive, and then I got more productive. This echoes Jamie Brandon’s thoughts on moving faster: the most powerful precursor to moving faster is caring about moving faster. A lot of the most powerful things on this list come not from reading books or blog posts on productivity, but instead from observing and taking notes and then trying to deal with my individual problems and bottlenecks. I think this is underrated across most domains. The biggest wins on this list are team-centric: instituting team norms around pull requests and refinement, getting the entire team a working local setup, reducing our team’s dependence on a flaky and competitive QA environment, getting help from teammates and using these meetings to spread context throughout the team, ensuring I come to standup with extremely detailed updates to keep the team informed, etc. I think it goes without saying that overall team productivity matters more than individual productivity, and that communication is a big source of latency and therefore an obvious place to optimize (alternatively, that team-wide improvements yield far more). However, I find that the faster I can deal with my own tasks, the more breathing room I have to consider how the team could be working more smoothly. Things I have not tried but think might work Recording myself programming and reviewing the tapes I don’t do enough programming outside work hours to justify this, and I’d feel weird setting up screen-recording on a work laptop. This would help answer a lot of questions I have: How does listening to music affect my productivity? What do I do differently on productive afternoons when compared to my less productive afternoons? I have theories on the above, but actually watching it happening would be better. Further reading Dan Luu’s “Some reasons to work on productivity and velocity” I mostly agree with his takeaways here, which is why I didn’t spend much time trying to justify why working on velocity is worth it Jamie Brandon’s “Speed Matters” and “Moving Faster” The specific speedup figures - e.g. “if you improve your velocity 10x you can do 5x every morning and go home after lunch” - reflect his never working on teams in a professional software engineering environment Cal Newport’s Deep Work The most relevant part here is about context switching and attention residue" />
<link rel="canonical" href="https://www.hamishpierpont.com/2023/09/13/notes-on-developer-velocity.html" />
<meta property="og:url" content="https://www.hamishpierpont.com/2023/09/13/notes-on-developer-velocity.html" />
<meta property="og:site_name" content="Hamish Pierpont’s blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-09-13T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Notes on developer velocity" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-09-13T00:00:00-04:00","datePublished":"2023-09-13T00:00:00-04:00","description":"I am a software engineer, just shy of two years into my career. My team and I have spent the last few months closing out a major effort, with lots of pressure Inspired by similar posts by Dan Luu and Jamie Brandon, I addressed this challenge by putting lots of effort into improving my throughput. I’m happy with this result: using the highly flawed metric of “story points completed per sprint,” my output tracks 50 to 100% higher than it used to, with no discernible change in the way we estimate task complexity. More tangibly, I added a big nasty feature to our product, which is one of the top priorities for my organization. Here are a few notes about what worked. Note that this post is about getting a lot done. It’s not a justification for overwork, or an endorsement of working outside business hours - it’s just one person’s thoughts about how to get a lot done when the time calls for it. I don’t have kids, I live a short walk to my place of work, and my level of expertise relative to that of my peers is low, even though that gap is closing. I’m also in the uncommon - but not unique - situation of working in an office with none of my close coworkers working from that same office, so I have unusually high autonomy in how I spend my time. The opportunity cost of not getting lunch with your manager is not a concern when your manager is three states away. Keep feedback loops as short as possible When under constant pressure to close tickets and put out fires, developers rarely get to step back and examine their processes. This often leads to inefficient team processes that: Could be optimized with a few days of developer attention or less Routinely waste hours of developer time Do not directly relate to adding features, and therefore often go overlooked for days or months. Individual level: testing practices My IDE reports problems with my code with a latency of a few seconds. The Maven tasks for our repository take anywhere from a few seconds to a minutes. A full local build running checkstyle, unit tests, and coverage analysis takes five or six minutes. Running integration tests locally might take ten minutes. Running our full dev pipeline on Jenkins takes at least an hour if there are no builds in the queue. My golden rule is to never let a problem that could be caught in a shorter feedback loop go undetected until a longer one is run. This saves time in two ways: by not wasting forty-five minutes of pipeline build time on a code style issue that could have been caught with a fifteen-second run of mvn:checkstyle check, and by shortening feedback loops to the point where I don’t feel tempted to switch tasks. Returning to my original productivity level after a context switch takes a few minutes at least, and I think that every context switch through the day accumulates slime on the surface of my brain that makes it harder to focus. This suggests running all the various checks on your work in ascending order of their time length - e.g. run the linter first. When I didn’t feel the need to squeeze the most out of every minute and hour, I wasn’t as strict with this rule and wasted lots of time as a result. This also suggests adding everything into your IDE that you can. My team uses SonarQube to enforce code quality in our pipeline, but never set up SonarQube integration in our IDEs. We’ve had several pipeline builds fail due to SonarQube code smells. Every time this happens we need to hunt down the exact issue in the SonarQube dashboard (the link to SonarQube in our pipeline logs has been broken for months so it’s not as simple as clicking the last line in the logs), resolve the issue, re-run our unit tests and checkstyle locally to make sure nothing changed, then push the changes and wait for the pipeline to build again. This is a mind-boggling waste of time when SonarQube integration in IntelliJ can highlight these problems immediately. Team level: end to end testing My team went several months without a way to test our frontend against our backend on our local machines. The config for the frontend pointed to the QA backend endpoint, even when the frontend was running locally. The fix wasn’t obvious because we don’t own the frontend or backend, and our compressed schedule meant we didn’t feel comfortable spending time on anything other than grinding through tickets. However, since we often had five different people working on features in the backend repository and all of their pull requests overwrote the QA backend service with each PR build, we were constantly stepping on each other’s toes; five minutes after my PR build deployed to QA and I could start testing my frontend and backend changes against each other, my teammate’s PR build would deploy to QA and overwrite my changes. This constant resource contention just to test frontend and backend changes together wasted days of developer time. One evening, I finally dug through the frontend code and found where the logic to send requests to our backend lived. I spent two hours tinkering with it and made some progress, but got confused by an issue with HTTPS and certificates. (Remember, I’m still pretty green). The next morning I handed my work to my senior developer during standup, and in a few hours he had figured out the cert issue. By the end of that day we all knew how to test our frontend changes against our backend changes locally. The feedback loop for testing frontend and backend changes against each other was immediately reduced from hours/days to one or two minutes. Ever since this change we’ve gone from barely fitting our tickets into the sprint or underdelivering on them to pulling fresh tickets from the backlog halfway through each sprint. Org level: pull request norms My team is currently on loan to help another project get across the finish line, so we don’t own any of the codebases or pipelines to which we contribute. We need approvals from the team that owns the project to merge pull requests. A common issue we run into is creating a big pull request, sending it off for review from that team, and then having to remind them aggressively to review our PRs, often not seeing reviews for several days. That team has to deal with lots of production incidents, owns multiple critical services, and has their own raft of PRs to review, so it’s not surprising that they aren’t always quick to review our PRs. They also do not trust our developers as much to write good code, since we have only worked with them for a few months and we spent much of that time learning the ropes. However, they do trust our manager, who they see frequently in cross-team meetings and outranks everyone on my team by one to three levels. When we instituted a team norm of getting PR approvals from at least one developer from our team and our manager before sending to our sister team for review, we saw a significant decrease in wait times for PR reviews. Another pernicious time-waster is undergoing multiple rounds of PR feedback, especially given the long lead time on PR reviews in my organization. Every round of requested changes requires another cycle of testing and PR builds that will take a few hours at minimum, possibly extending to a day or more if the pipeline is unstable or the clusters are being rehydrated. Some of this is irreducible complexity in the tasks, but after my first few PRs I noticed some common patterns of feedback. I started keeping track of this in my note-taking app, which eventually grew into a PR checklist. By reviewing my changes against the checklist every time I have something to contribute, I make sure that I won’t burn one or two PR review cycles on obvious things that my sister team will dislike; keeping this information in a note outside my head ensures I don’t forget anything. Become extremely comfortable with asking for help and asking questions I basically never needed to ask for help in grade school, and got through most of college without needing it either, so I came into my full-time engineering career uncomfortable with asking lots of questions because I didn’t want to look stupid. This seems to be a common failure mode for newer engineers. It is also one of the most damaging, because being a software developer is nothing like being a student. Since your team needs to get work done, in effect everything is a group project, and you need to pull your weight. But since you don’t know anything, and a lot of the requisite knowledge lives only in the heads of your fellow engineers, you will not be able to pull your weight until substantial amounts of senior engineer time has been spent teaching you. This is not a new revelation from the last few months, but its truth was borne out by the last few months. I had to implement a new frontend component in Angular. I have never written any real frontend code in my life. I could have grokked the basics from watching any Angular tutorial, but the specific knowledge of the codebase required to complete the work had to be transmitted into me directly from the brains of my fellow engineers. I spent tremendous amounts of time programming with my teammates during this effort. I would not have finished without them - just as an example, it took me and my senior engineer three days to get the frontend tests working for my changes, partially because we discovered bugs in the testing suite we inherited. If I had wasted too much time trying to understand it myself, I would have still needed to take several days of my senior engineer’s time, but I would have endangered our team’s timeline while doing it. A critical skill is to learn exactly when you should stop trying to figure something out and call for help. For me, since some of that psychological discomfort with asking for help remains, I often time-box how long I will allow myself to spin my wheels. This is often down to the five- or ten-minute mark: “if I can’t figure out the next step on this work by ten minutes from now, I’m asking for help.” Note that this is strictly inferior to asking right when you realize you’re stuck - this technique just guards against wasting an hour or more. In the same vein, I often find myself so confused that it’s hard to intelligently articulate my questions. When that happens, it’s a sign that other engineers need to be pulled in so I can talk it out with them. This is uncomfortable - stuttering through an explanation of what’s happening and grasping at the specific point of confusion is uncomfortable - but the options are to wrangle it by yourself and possibly burn an entire day trying to figure it out, or spend five to ten minutes vomiting words at your coworkers until all of a sudden the problem becomes clear. Your coworkers will be happy to spend this ten minutes if it means you actually accomplish your work and they don’t need to pick up the slack later. Be particular in refinement My team has landed on an objective standard for ticket refinement: every ticket should have enough information that any developer on the team could pick it up and know where to start, even if that doesn’t happen until several weeks from now. Since I am the newest on the team by a wide margin - and since one of my strengths is attention to detail - I often am the one asking for multiple rounds of clarifications to be made until the ticket reaches this standard. Consequently, I no longer get tickets that I find confusing - I can almost always get started on them the day I pick them up without needing to hunt people down for clarification. If this saves a few hours per sprint, which I think it does, then that’s pretty huge. This is another win with team-level benefits. I was in sprint retro earlier, and one of my team members called out how much easier it was to finish tickets on time without having to figure out what the ticket meant, often going back and forth with the ticket author to figure it out. This validates that other developers had the same issue and also wasted several hours each sprint. Dump and serialize mental state I take lots of notes at work, mostly using a journal format with one markdown file per day. At the end of the workday, I create the note for the next day and add a to-do list ordered with the most pressing or time-sensitive task at the top. I’ll also write out bullet points for standup outlining what I accomplished the day before, what I’ll aim to accomplish that day, any blockers, and any topics to discuss during our parking lot. By dumping my current mental state at the end of the workday into this note and structuring it in this manner, I find it a lot easier to relax after work knowing that the pertinent info I’ll need for the next day is written down. I also give much more thoughtful and detailed standup updates, surfacing any issues that require team help and proving to my coworkers (including my manager and PM) that I am actually getting a lot done. Having this clear log of what’s getting done also helps a lot during performance management, as I can refer to examples of good work down to the day it was completed. Finally, arriving at work knowing exactly what to do first lets me capitalize on my most productive hours in the morning. Sometimes this means staying an extra fifteen minutes to collate the information, but I think it’s worth it. Always capitalize on your most productive hours Some people are morning people and some people are night people. I, myself, am an “everytime but mid-afternoon” person - I can be laser-focused in the morning until my first meeting and pretty good until I break for lunch, which takes a while to come back from. Getting anything done from 2:30 to 4:30 requires an elaborate array of ruses and tricks. Knowing this, I try to get in before the morning rush so I can get to work before the office fills with people - normally around 8:45 AM. I’ll also delay lunch to 12:30 or later and keep it short by bringing lunch from home. Elongating my morning from three hours to four-ish is an incredible boon to my productivity, especially the time I gain before my 10am standup. I do still socialize at lunch, but maybe a bit less than normal. For the rest of the working day, I’ll do my best to focus. Sometimes I do so quite successfully! Sometimes I’m booked solid with meetings, or just have a hard time focusing, but this matters less when I spend the first four hours of the day in productive bliss. I try not to work much past 5pm, but sometimes it can’t be avoided. When I do, I find that I can actually do quite a bit once the office thins out around 5pm and the distractions go away. I’ll work until 7pm at the latest, normally getting quite a bit done. Then I’ll put the computer down, walk home, eat, and get on with my evening. If the mood strikes me, I’ll re-open my computer briefly sometime between 10:30 and 11. My brain is now well-rested and can fit in a small, discrete task before I got to bed at midnight - like drafting a pull request description, writing my to-do list, or outlining what I’ll say in standup so I don’t have to use productive morning time for it. This time helps me align my priorities for the next day to ensure I tackle the most important thing right when I get started. Work where you are most productive I struggle mightily with working from home, and have for as long as I can remember. In high school I could knock out math homework in a thirty-minute lunch, while eating, that might have taken me more than an hour at home. In college my grades correlated highly with how much time I spent in the library and in cafes - I’d work from my apartment only if I was in real trouble. (When COVID made all learning remote, you can imagine how fucked I was). I spent the first six months of my full-time job working from my parents’ house in Florida, and I only got decent results by working brutal hours and having a lot of prior experience - my median per-hour productivity sucked. For this reason I go to the office all five days a week, despite my company only mandating 2.5 days a week. It’s just much easier for me to get work done, especially on Mondays and Fridays when the office is dead. If I felt that I was much more productive working from home, I would be scheming every way possible to maximize my time spent working from home, including applying for a remote exception at my job. This idea goes hand in glove with working during hours of peak productivity. Working in my best environment, when I feel sharpest, is a game changer. Always have work in the queue Despite all the efforts to reduce our time spent waiting, tasks inevitably get blocked and context switching becomes necessary. I make sure to always have other work queued up and ready to go. When I write down my to-do list at the end of every day, even if I expect to spend the entire next day on a certain effort, I make sure I have the next step for another effort added to the end of my to-do list so I can go straight into it once I’m blocked. If I don’t know what this next task is, I know I need to bring it up in standup the next day to get help understanding the context of the ticket - but then again, since I’m persistent in refinement, I normally know the next step for each task. Do all the “life” stuff you already know you should be doing When my nightly sleep drops below seven hours per night, I start having terrible days at work where I get nothing done and lose track of work discussions. If I’m not eating well, it exacerbates the negative performance effects of working in the afternoon and affects my sleep. If I’m not exercising (which for me is lifting weights, running, and walking everywhere), I can’t sit still at work long enough to focus. Everyone already knows that they should be sleeping to the point of maximal focus, doing regular exercise, and eating a balanced diet. If you feel you struggle with any of these, it’s worth the time and effort to figure out why. I wasted five years of my life sleeping terribly because I drank black coffee and diet soda like it was water, so I never felt the full effects of sleepiness and never made the effort to sleep better. Nowadays I’m much more cautious about my caffeine intake and my sleep is much better. There was a point in my life where I neither ate well nor exercised. It took a lot of careful self-observation and journaling to convince myself of their benefits, but now it’s obvious to me when I’m not doing them because I feel absolutely terrible. If any of these start slipping, it shows up in my work performance and I know I need to course-correct. General thoughts on process and takeaways In the last few months I suddenly had to care about being more productive, and then I got more productive. This echoes Jamie Brandon’s thoughts on moving faster: the most powerful precursor to moving faster is caring about moving faster. A lot of the most powerful things on this list come not from reading books or blog posts on productivity, but instead from observing and taking notes and then trying to deal with my individual problems and bottlenecks. I think this is underrated across most domains. The biggest wins on this list are team-centric: instituting team norms around pull requests and refinement, getting the entire team a working local setup, reducing our team’s dependence on a flaky and competitive QA environment, getting help from teammates and using these meetings to spread context throughout the team, ensuring I come to standup with extremely detailed updates to keep the team informed, etc. I think it goes without saying that overall team productivity matters more than individual productivity, and that communication is a big source of latency and therefore an obvious place to optimize (alternatively, that team-wide improvements yield far more). However, I find that the faster I can deal with my own tasks, the more breathing room I have to consider how the team could be working more smoothly. Things I have not tried but think might work Recording myself programming and reviewing the tapes I don’t do enough programming outside work hours to justify this, and I’d feel weird setting up screen-recording on a work laptop. This would help answer a lot of questions I have: How does listening to music affect my productivity? What do I do differently on productive afternoons when compared to my less productive afternoons? I have theories on the above, but actually watching it happening would be better. Further reading Dan Luu’s “Some reasons to work on productivity and velocity” I mostly agree with his takeaways here, which is why I didn’t spend much time trying to justify why working on velocity is worth it Jamie Brandon’s “Speed Matters” and “Moving Faster” The specific speedup figures - e.g. “if you improve your velocity 10x you can do 5x every morning and go home after lunch” - reflect his never working on teams in a professional software engineering environment Cal Newport’s Deep Work The most relevant part here is about context switching and attention residue","headline":"Notes on developer velocity","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.hamishpierpont.com/2023/09/13/notes-on-developer-velocity.html"},"url":"https://www.hamishpierpont.com/2023/09/13/notes-on-developer-velocity.html"}</script>
<!-- End Jekyll SEO tag -->

  </head>
  <body>
    <nav>
    
    <a href="/" >
        Home
    </a>
    
    <a href="/blog.html" >
        Blog
    </a>
    
    <a href="/feed.xml" >
        RSS
    </a>
    
</nav>
    <h1>Notes on developer velocity</h1>

<p></p>

<p><i>13 Sep 2023</i></p>

<p>I am a software engineer, just shy of two years into my career. My team and I have spent the last few months closing out a major effort, with lots of pressure</p>

<p>Inspired by similar posts by <a href="https://danluu.com/productivity-velocity/">Dan Luu</a> and <a href="https://www.scattered-thoughts.net/writing/moving-faster/">Jamie Brandon</a>, I addressed this challenge by putting lots of effort into improving my throughput. I’m happy with this result: using the highly flawed metric of “story points completed per sprint,” my output tracks 50 to 100% higher than it used to, with no discernible change in the way we estimate task complexity. More tangibly, I added a big nasty feature to our product, which is one of the top priorities for my organization. Here are a few notes about what worked.</p>

<p>Note that this post is about getting a lot done. It’s not a justification for overwork, or an endorsement of working outside business hours - it’s just one person’s thoughts about how to get a lot done when the time calls for it. I don’t have kids, I live a short walk to my place of work, and my level of expertise relative to that of my peers is low, even though that gap is closing. I’m also in the uncommon - but not unique - situation of working in an office with none of my close coworkers working from that same office, so I have unusually high autonomy in how I spend my time. The opportunity cost of not getting lunch with your manager is not a concern when your manager is three states away.</p>

<h2 id="keep-feedback-loops-as-short-as-possible">Keep feedback loops as short as possible</h2>

<p>When under constant pressure to close tickets and put out fires, developers rarely get to step back and examine their processes. This often leads to inefficient team processes that:</p>
<ol>
  <li>Could be optimized with a few days of developer attention or less</li>
  <li>Routinely waste hours of developer time</li>
  <li>Do not directly relate to adding features, and therefore often go overlooked for days or months.</li>
</ol>

<h3 id="individual-level-testing-practices">Individual level: testing practices</h3>

<p>My IDE reports problems with my code with a latency of a few seconds. The Maven tasks for our repository take anywhere from a few seconds to a minutes. A full local build running checkstyle, unit tests, and coverage analysis takes five or six minutes. Running integration tests locally might take ten minutes. Running our full dev pipeline on Jenkins takes at least an hour if there are no builds in the queue.</p>

<p>My golden rule is to never let a problem that could be caught in a shorter feedback loop go undetected until a longer one is run. This saves time in two ways: by not wasting forty-five minutes of pipeline build time on a code style issue that could have been caught with a fifteen-second run of <code class="language-plaintext highlighter-rouge">mvn:checkstyle check</code>, and by shortening feedback loops to the point where I don’t feel tempted to switch tasks. Returning to my original productivity level after a context switch takes a few minutes at least, and I think that every context switch through the day accumulates slime on the surface of my brain that makes it harder to focus. This suggests running all the various checks on your work in ascending order of their time length - e.g. run the linter first.</p>

<p>When I didn’t feel the need to squeeze the most out of every minute and hour, I wasn’t as strict with this rule and wasted lots of time as a result.</p>

<p>This also suggests adding everything into your IDE that you can. My team uses SonarQube to enforce code quality in our pipeline, but never set up SonarQube integration in our IDEs. We’ve had several pipeline builds fail due to SonarQube code smells. Every time this happens we need to hunt down the exact issue in the SonarQube dashboard (the link to SonarQube in our pipeline logs has been broken for months so it’s not as simple as clicking the last line in the logs), resolve the issue, re-run our unit tests and checkstyle locally to make sure nothing changed, then push the changes and wait for the pipeline to build again. This is a mind-boggling waste of time when SonarQube integration in IntelliJ can highlight these problems immediately.</p>

<h3 id="team-level-end-to-end-testing">Team level: end to end testing</h3>

<p>My team went several months without a way to test our frontend against our backend on our local machines. The config for the frontend pointed to the QA backend endpoint, even when the frontend was running locally. The fix wasn’t obvious because we don’t own the frontend or backend, and our compressed schedule meant we didn’t feel comfortable spending time on anything other than grinding through tickets. However, since we often had five different people working on features in the backend repository and all of their pull requests overwrote the QA backend service with each PR build, we were constantly stepping on each other’s toes; five minutes after my PR build deployed to QA and I could start testing my frontend and backend changes against each other, my teammate’s PR build would deploy to QA and overwrite my changes. This constant resource contention just to test frontend and backend changes together wasted days of developer time.</p>

<p>One evening, I finally dug through the frontend code and found where the logic to send requests to our backend lived. I spent two hours tinkering with it and made some progress, but got confused by an issue with HTTPS and certificates. (Remember, I’m still pretty green). The next morning I handed my work to my senior developer during standup, and in a few hours he had figured out the cert issue. By the end of that day we all knew how to test our frontend changes against our backend changes locally.</p>

<p>The feedback loop for testing frontend and backend changes against each other was immediately reduced from hours/days to one or two minutes. Ever since this change we’ve gone from barely fitting our tickets into the sprint or underdelivering on them to pulling fresh tickets from the backlog halfway through each sprint.</p>

<h3 id="org-level-pull-request-norms">Org level: pull request norms</h3>

<p>My team is currently on loan to help another project get across the finish line, so we don’t own any of the codebases or pipelines to which we contribute. We need approvals from the team that owns the project to merge pull requests. A common issue we run into is creating a big pull request, sending it off for review from that team, and then having to remind them aggressively to review our PRs, often not seeing reviews for several days. That team has to deal with lots of production incidents, owns multiple critical services,  and has their own raft of PRs to review, so it’s not surprising that they aren’t always quick to review our PRs. They also do not trust our developers as much to write good code, since we have only worked with them for a few months and we spent much of that time learning the ropes. However, they do trust our manager, who they see frequently in cross-team meetings and outranks everyone on my team by one to three levels. When we instituted a team norm of getting PR approvals from at least one developer from our team <em>and</em> our manager before sending to our sister team for review, we saw a significant decrease in wait times for PR reviews.</p>

<p>Another pernicious time-waster is undergoing multiple rounds of PR feedback, especially given the long lead time on PR reviews in my organization. Every round of requested changes requires another cycle of testing and PR builds that will take a few hours at minimum, possibly extending to a day or more if the pipeline is unstable or the clusters are being rehydrated. Some of this is irreducible complexity in the tasks, but after my first few PRs I noticed some common patterns of feedback. I started keeping track of this in my note-taking app, which eventually grew into a PR checklist. By reviewing my changes against the checklist every time I have something to contribute, I make sure that I won’t burn one or two PR review cycles on obvious things that my sister team will dislike; keeping this information in a note outside my head ensures I don’t forget anything.</p>

<h2 id="become-extremely-comfortable-with-asking-for-help-and-asking-questions">Become extremely comfortable with asking for help and asking questions</h2>

<p>I basically never needed to ask for help in grade school, and got through most of college without needing it either, so I came into my full-time engineering career uncomfortable with asking lots of questions because I didn’t want to look stupid. This seems to be a common failure mode for newer engineers. It is also one of the most damaging, because being a software developer is nothing like being a student. Since your team needs to get work done, in effect everything is a group project, and you need to pull your weight. But since you don’t know anything, and a lot of the requisite knowledge lives only in the heads of your fellow engineers, you will not be able to pull your weight until substantial amounts of senior engineer time has been spent teaching you.</p>

<p>This is not a new revelation from the last few months, but its truth was borne out by the last few months. I had to implement a new frontend component in Angular. I have never written any real frontend code in my life. I could have grokked the basics from watching any Angular tutorial, but the specific knowledge of the codebase required to complete the work had to be transmitted into me directly from the brains of my fellow engineers. I spent tremendous amounts of time programming with my teammates during this effort. I would not have finished without them - just as an example, it took me and my senior engineer three days to get the frontend tests working for my changes, partially because we discovered bugs in the testing suite we inherited. If I had wasted too much time trying to understand it myself, I would have still needed to take several days of my senior engineer’s time, but I would have endangered our team’s timeline while doing it.</p>

<p>A critical skill is to learn exactly when you should stop trying to figure something out and call for help. For me, since some of that psychological discomfort with asking for help remains, I often time-box how long I will allow myself to spin my wheels. This is often down to the five- or ten-minute mark: “if I can’t figure out the next step on this work by ten minutes from now, I’m asking for help.” Note that this is strictly inferior to asking right when you realize you’re stuck - this technique just guards against wasting an hour or more.</p>

<p>In the same vein, I often find myself so confused that it’s hard to intelligently articulate my questions. When that happens, it’s a sign that other engineers need to be pulled in so I can talk it out with them. This is uncomfortable - stuttering through an explanation of what’s happening and grasping at the specific point of confusion is uncomfortable - but the options are to wrangle it by yourself and possibly burn an entire day trying to figure it out, or spend five to ten minutes vomiting words at your coworkers until all of a sudden the problem becomes clear. Your coworkers will be happy to spend this ten minutes if it means you actually accomplish your work and they don’t need to pick up the slack later.</p>

<h2 id="be-particular-in-refinement">Be particular in refinement</h2>

<p>My team has landed on an objective standard for ticket refinement: every ticket should have enough information that any developer on the team could pick it up and know where to start, even if that doesn’t happen until several weeks from now. Since I am the newest on the team by a wide margin - and since one of my strengths is attention to detail - I often am the one asking for multiple rounds of clarifications to be made until the ticket reaches this standard. Consequently, I no longer get tickets that I find confusing - I can almost always get started on them the day I pick them up without needing to hunt people down for clarification. If this saves a few hours per sprint, which I think it does, then that’s pretty huge.</p>

<p>This is another win with team-level benefits. I was in sprint retro earlier, and one of my team members called out how much easier it was to finish tickets on time without having to figure out what the ticket meant, often going back and forth with the ticket author to figure it out. This validates that other developers had the same issue and also wasted several hours each sprint.</p>

<h2 id="dump-and-serialize-mental-state">Dump and serialize mental state</h2>

<p>I take lots of notes at work, mostly using a journal format with one markdown file per day. At the end of the workday, I create the note for the next day and add a to-do list ordered with the most pressing or time-sensitive task at the top. I’ll also write out bullet points for standup outlining what I accomplished the day before, what I’ll aim to accomplish that day, any blockers, and any topics to discuss during our parking lot.</p>

<p>By dumping my current mental state at the end of the workday into this note and structuring it in this manner, I find it a lot easier to relax after work knowing that the pertinent info I’ll need for the next day is written down. I also give much more thoughtful and detailed standup updates, surfacing any issues that require team help and proving to my coworkers (including my manager and PM) that I am actually getting a lot done. Having this clear log of what’s getting done also helps a lot during performance management, as I can refer to examples of good work down to the day it was completed. Finally, arriving at work knowing exactly what to do first lets me capitalize on my most productive hours in the morning.</p>

<p>Sometimes this means staying an extra fifteen minutes to collate the information, but I think it’s worth it.</p>

<h2 id="always-capitalize-on-your-most-productive-hours">Always capitalize on your most productive hours</h2>

<p>Some people are morning people and some people are night people. I, myself, am an “everytime but mid-afternoon” person - I can be laser-focused in the morning until my first meeting and pretty good until I break for lunch, which takes a while to come back from. Getting anything done from 2:30 to 4:30 requires an elaborate array of ruses and tricks.</p>

<p>Knowing this, I try to get in before the morning rush so I can get to work before the office fills with people - normally around 8:45 AM. I’ll also delay lunch to 12:30 or later and keep it short by bringing lunch from home. Elongating my morning from three hours to four-ish is an incredible boon to my productivity, especially the time I gain before my 10am standup. I do still socialize at lunch, but maybe a bit less than normal.</p>

<p>For the rest of the working day, I’ll do my best to focus. Sometimes I do so quite successfully! Sometimes I’m booked solid with meetings, or just have a hard time focusing, but this matters less when I spend the first four hours of the day in productive bliss.</p>

<p>I try not to work much past 5pm, but sometimes it can’t be avoided. When I do, I find that I can actually do quite a bit once the office thins out around 5pm and the distractions go away. I’ll work until 7pm at the latest, normally getting quite a bit done. Then I’ll put the computer down, walk home, eat, and get on with my evening. If the mood strikes me, I’ll re-open my computer briefly sometime between 10:30 and 11. My brain is now well-rested and can fit in a small, discrete task before I got to bed at midnight - like drafting a pull request description, writing my to-do list, or outlining what I’ll say in standup so I don’t have to use productive morning time for it. This time helps me align my priorities for the next day to ensure I tackle the most important thing right when I get started.</p>

<h2 id="work-where-you-are-most-productive">Work where you are most productive</h2>

<p>I struggle mightily with working from home, and have for as long as I can remember. In high school I could knock out math homework in a thirty-minute lunch, while eating, that might have taken me more than an hour at home. In college my grades correlated highly with how much time I spent in the library and in cafes - I’d work from my apartment only if I was in real trouble. (When COVID made all learning remote, you can imagine how fucked I was). I spent the first six months of my full-time job working from my parents’ house in Florida, and I only got decent results by working brutal hours and having a lot of prior experience - my median per-hour productivity sucked.</p>

<p>For this reason I go to the office all five days a week, despite my company only mandating 2.5 days a week. It’s just much easier for me to get work done, especially on Mondays and Fridays when the office is dead. If I felt that I was much more productive working from home, I would be scheming every way possible to maximize my time spent working from home, including applying for a remote exception at my job.</p>

<p>This idea goes hand in glove with working during hours of peak productivity. Working in my best environment, when I feel sharpest, is a game changer.</p>

<h2 id="always-have-work-in-the-queue">Always have work in the queue</h2>

<p>Despite all the efforts to reduce our time spent waiting, tasks inevitably get blocked and context switching becomes necessary. I make sure to always have other work queued up and ready to go. When I write down my to-do list at the end of every day, even if I expect to spend the entire next day on a certain effort, I make sure I have the next step for another effort added to the end of my to-do list so I can go straight into it once I’m blocked. If I don’t know what this next task is, I know I need to bring it up in standup the next day to get help understanding the context of the ticket - but then again, since I’m persistent in refinement, I normally know the next step for each task.</p>

<h2 id="do-all-the-life-stuff-you-already-know-you-should-be-doing">Do all the “life” stuff you already know you should be doing</h2>

<p>When my nightly sleep drops below seven hours per night, I start having terrible days at work where I get nothing done and lose track of work discussions. If I’m not eating well, it exacerbates the negative performance effects of working in the afternoon and affects my sleep. If I’m not exercising (which for me is lifting weights, running, and walking everywhere), I can’t sit still at work long enough to focus.</p>

<p>Everyone already knows that they should be sleeping to the point of maximal focus, doing regular exercise, and eating a balanced diet. If you feel you struggle with any of these, it’s worth the time and effort to figure out why. I wasted five years of my life sleeping terribly because I drank black coffee and diet soda like it was water, so I never felt the full effects of sleepiness and never made the effort to sleep better. Nowadays I’m much more cautious about my caffeine intake and my sleep is much better. There was a point in my life where I neither ate well nor exercised. It took a lot of careful self-observation and journaling to convince myself of their benefits, but now it’s obvious to me when I’m not doing them because I feel absolutely terrible. If any of these start slipping, it shows up in my work performance and I know I need to course-correct.</p>

<h2 id="general-thoughts-on-process-and-takeaways">General thoughts on process and takeaways</h2>

<p>In the last few months I suddenly had to care about being more productive, and then I got more productive. This echoes Jamie Brandon’s thoughts on moving faster: the most powerful precursor to moving faster is caring about moving faster.</p>

<p>A lot of the most powerful things on this list come not from reading books or blog posts on productivity, but instead from observing and taking notes and then trying to deal with my individual problems and bottlenecks. I think this is underrated across most domains.</p>

<p>The biggest wins on this list are team-centric: instituting team norms around pull requests and refinement, getting the entire team a working local setup, reducing our team’s dependence on a flaky and competitive QA environment, getting help from teammates and using these meetings to spread context throughout the team, ensuring I come to standup with extremely detailed updates to keep the team informed, etc. I think it goes without saying that overall team productivity matters more than individual productivity, and that communication is a big source of latency and therefore an obvious place to optimize (alternatively, that team-wide improvements yield far more). However, I find that the faster I can deal with my own tasks, the more breathing room I have to consider how the team could be working more smoothly.</p>

<h2 id="things-i-have-not-tried-but-think-might-work">Things I have not tried but think might work</h2>
<ul>
  <li>Recording myself programming and reviewing the tapes
    <ul>
      <li>I don’t do enough programming outside work hours to justify this, and I’d feel weird setting up screen-recording on a work laptop. This would help answer a lot of questions I have:
        <ul>
          <li>How does listening to music affect my productivity?</li>
          <li>What do I do differently on productive afternoons when compared to my less productive afternoons?</li>
        </ul>
      </li>
      <li>I have theories on the above, but actually watching it happening would be better.</li>
    </ul>
  </li>
</ul>

<h2 id="further-reading">Further reading</h2>
<ul>
  <li>Dan Luu’s <a href="https://danluu.com/productivity-velocity/">“Some reasons to work on productivity and velocity”</a>
    <ul>
      <li>I mostly agree with his takeaways here, which is why I didn’t spend much time trying to justify why working on velocity is worth it</li>
    </ul>
  </li>
  <li>Jamie Brandon’s <a href="https://www.scattered-thoughts.net/writing/speed-matters/">“Speed Matters”</a> and <a href="https://www.scattered-thoughts.net/writing/moving-faster/">“Moving Faster”</a>
    <ul>
      <li>The specific speedup figures - e.g. “if you improve your velocity 10x you can do 5x every morning and go home after lunch” - reflect his never working on teams in a professional software engineering environment</li>
    </ul>
  </li>
  <li>Cal Newport’s <a href="https://www.amazon.com/gp/product/1455586692/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;tag=stuhac-20&amp;creative=9325&amp;linkCode=as2&amp;creativeASIN=1455586692&amp;linkId=ec7ed5a0e59a7cff8b7833d3e8e560c7"><em>Deep Work</em></a>
    <ul>
      <li>The most relevant part here is about context switching and attention residue</li>
    </ul>
  </li>
</ul>

    <link rel="stylesheet" href="/assets/css/styles.css">
  </body>
</html>